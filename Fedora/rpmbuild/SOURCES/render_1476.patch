From 95a893c3f8fc59df76557fcbe6fcbdf25a248297 Mon Sep 17 00:00:00 2001
From: Olivier Fourdan <ofourdan@redhat.com>
Date: Fri, 5 Apr 2024 15:19:24 +0200
Subject: [PATCH 1/2] render: Have AddGlyph return whether the glyph was added

AddGlyph() may free the GlyphPtr that was passed to it, potentially
causing trouble to the caller who may try to fiddle with the GlyphPtr
after it was added to the glyph set.

Have AddGlyph() return a boolean indicating whether the GlyphPtr that
was given was actually added or another existing glyph reused so the
caller can tell if the given GlyphPtr is still valid on return.

This is preparation work for the following commit.

v2: AddGlyph() to return a boolean instead of a GlyphPtr (Michel)

Signed-off-by: Olivier Fourdan <ofourdan@redhat.com>
---
 render/glyph.c         | 6 +++++-
 render/glyphstr.h      | 2 +-
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/render/glyph.c b/render/glyph.c
index 13991f8a12..d00ef2df9d 100644
--- a/render/glyph.c
+++ b/render/glyph.c
@@ -279,11 +279,12 @@ FreeGlyph(GlyphPtr glyph, int format)
     }
 }
 
-void
+Bool
 AddGlyph(GlyphSetPtr glyphSet, GlyphPtr glyph, Glyph id)
 {
     GlyphRefPtr gr;
     CARD32 signature;
+    Bool glyph_added = TRUE;
 
     CheckDuplicates(&globalGlyphs[glyphSet->fdepth], "AddGlyph top global");
     /* Locate existing matching glyph */
@@ -294,6 +295,7 @@ AddGlyph(GlyphSetPtr glyphSet, GlyphPtr glyph, Glyph id)
         FreeGlyphPicture(glyph);
         dixFreeObjectWithPrivates(glyph, PRIVATE_GLYPH);
         glyph = gr->glyph;
+        glyph_added = FALSE;
     }
     else if (gr->glyph != glyph) {
         gr->glyph = glyph;
@@ -311,6 +313,8 @@ AddGlyph(GlyphSetPtr glyphSet, GlyphPtr glyph, Glyph id)
     gr->glyph = glyph;
     gr->signature = id;
     CheckDuplicates(&globalGlyphs[glyphSet->fdepth], "AddGlyph bottom");
+
+    return glyph_added;
 }
 
 Bool
diff --git a/render/glyphstr_priv.h b/render/glyphstr_priv.h
index dd1bc54825..a2ddecd744 100644
--- a/render/glyphstr.h
+++ b/render/glyphstr.h
@@ -99,7 +99,7 @@
 HashGlyph(xGlyphInfo * gi,
           CARD8 *bits, unsigned long size, unsigned char sha1[20]);
 
-extern void
+extern Bool
  AddGlyph(GlyphSetPtr glyphSet, GlyphPtr glyph, Glyph id);
 
 extern Bool
-- 
GitLab


From 66274c4055a62c42fc0d2e68e27853aa53682ad9 Mon Sep 17 00:00:00 2001
From: Olivier Fourdan <ofourdan@redhat.com>
Date: Fri, 5 Apr 2024 15:24:49 +0200
Subject: [PATCH 2/2] render: Avoid possible double-free in
 ProcRenderAddGlyphs()

ProcRenderAddGlyphs() adds the glyph to the glyphset using AddGlyph() and
then frees it using FreeGlyph() to decrease the reference count, after
AddGlyph() has increased it.

AddGlyph() however may chose to reuse an existing glyph if it's already
in the glyphSet, and free the glyph that was given, in which case the
caller function, ProcRenderAddGlyphs() will call FreeGlyph() on an
already freed glyph, as reported by ASan:

  READ of size 4 thread T0
    #0 in FreeGlyph xserver/render/glyph.c:252
    #1 in ProcRenderAddGlyphs xserver/render/render.c:1174
    #2 in Dispatch xserver/dix/dispatch.c:546
    #3 in dix_main xserver/dix/main.c:271
    #4 in main xserver/dix/stubmain.c:34
    #5 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58
    #6 in __libc_start_main_impl ../csu/libc-start.c:360
    #7  (/usr/bin/Xwayland+0x44fe4)
  Address is located 0 bytes inside of 64-byte region
  freed by thread T0 here:
    #0 in __interceptor_free libsanitizer/asan/asan_malloc_linux.cpp:52
    #1 in _dixFreeObjectWithPrivates xserver/dix/privates.c:538
    #2 in AddGlyph xserver/render/glyph.c:295
    #3 in ProcRenderAddGlyphs xserver/render/render.c:1173
    #4 in Dispatch xserver/dix/dispatch.c:546
    #5 in dix_main xserver/dix/main.c:271
    #6 in main xserver/dix/stubmain.c:34
    #7 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58
  previously allocated by thread T0 here:
    #0 in __interceptor_malloc libsanitizer/asan/asan_malloc_linux.cpp:69
    #1 in AllocateGlyph xserver/render/glyph.c:355
    #2 in ProcRenderAddGlyphs xserver/render/render.c:1085
    #3 in Dispatch xserver/dix/dispatch.c:546
    #4 in dix_main xserver/dix/main.c:271
    #5 in main xserver/dix/stubmain.c:34
    #6 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58
  SUMMARY: AddressSanitizer: heap-use-after-free xserver/render/glyph.c:252 in FreeGlyph

To avoid that, check whether AddGlyph() changed the glyph that was passed
to it, in which case we ought not to free it since it's already freed.

v2: Simplify the test using the boolean returned from AddGlyph() (Michel)

Fixes: bdca6c3d1 - render: fix refcounting of glyphs during ProcRenderAddGlyphs
Closes: https://gitlab.freedesktop.org/xorg/xserver/-/issues/1659
Signed-off-by: Olivier Fourdan <ofourdan@redhat.com>
---
 render/render.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/render/render.c b/render/render.c
index fe5e37dd9a..b76cc21ad3 100644
--- a/render/render.c
+++ b/render/render.c
@@ -1170,8 +1170,8 @@ ProcRenderAddGlyphs(ClientPtr client)
         goto bail;
     }
     for (i = 0; i < nglyphs; i++) {
-        AddGlyph(glyphSet, glyphs[i].glyph, glyphs[i].id);
-        FreeGlyph(glyphs[i].glyph, glyphSet->fdepth);
+        if (AddGlyph(glyphSet, glyphs[i].glyph, glyphs[i].id))
+            FreeGlyph(glyphs[i].glyph, glyphSet->fdepth);
     }
 
     if (glyphsBase != glyphsLocal)
-- 
GitLab

